<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Be My Valentine ‚ù§Ô∏è</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Inter:wght@400;700&display=swap" rel="stylesheet">

<style>
:root {
  --accent:#ff4d6d;
  --cursor-x:50%;
  --cursor-y:50%;
}

/* RESET */
* {
  margin:0;
  padding:0;
  box-sizing:border-box;
}

html, body {
  width:100%;
  height:100%;
  overflow:hidden;
  font-family:'Inter',sans-serif;
  background:#ff8fa3;
  display:flex;
  align-items:center;
  justify-content:center;
}

/* BACKGROUND FLUID CANVAS */
#fluid-canvas {
  position:fixed;
  inset:0;
  z-index:0;
  pointer-events:none;
}

/* GRADIENT LAYER */
#bg-shader {
  position:fixed;
  inset:0;
  z-index:1;
  background: radial-gradient(circle at var(--cursor-x) var(--cursor-y),
    #ffb3c1 0%,
    #ff8fa3 40%,
    #fb6f92 100%);
}

/* CARD */
.glass-surface {
  position:relative;
  z-index:10;
  width:450px;
  padding:4rem;
  text-align:center;
  border-radius:40px;
  backdrop-filter: blur(25px);
  background: rgba(255,255,255,0.15);
  border:1px solid rgba(255,255,255,0.3);
  box-shadow:0 25px 50px rgba(0,0,0,0.2);
  animation: breathe 4s ease-in-out infinite;
}

@keyframes breathe {
  0%,100% { transform:scale(1); }
  50% { transform:scale(1.03); }
}

/* FACE */
.face-box {
  width:130px;
  height:130px;
  background:white;
  border-radius:50%;
  margin:0 auto 2.5rem;
  position:relative;
  box-shadow:0 10px 30px rgba(255,77,109,0.3);
  animation: floatFace 3s ease-in-out infinite;
}

@keyframes floatFace {
  0%,100% { transform:translateY(0); }
  50% { transform:translateY(-6px); }
}

.eyes {
  display:flex;
  justify-content:center;
  gap:25px;
  padding-top:42px;
}

.eye {
  width:18px;
  height:18px;
  background:#333;
  border-radius:50%;
  position:relative;
  overflow:hidden;
  animation: blink 5s infinite;
}

@keyframes blink {
  0%,95%,100% { height:18px; }
  97% { height:2px; }
}

.pupil {
  width:7px;
  height:7px;
  background:white;
  border-radius:50%;
  position:absolute;
  top:3px;
  left:3px;
  transition:transform 0.1s linear;
}

.mouth {
  width:45px;
  height:12px;
  border-bottom:5px solid #333;
  border-radius:50%;
  margin:14px auto;
  transition:0.4s ease;
}

.face-box:hover .mouth {
  width:26px;
  height:26px;
  background:red;
  border:none;
  clip-path: polygon(50% 80%, 100% 30%, 80% 0, 50% 20%, 20% 0, 0 30%);
}

/* BLUSH */
.blush {
  position:absolute;
  width:22px;
  height:12px;
  background:rgba(255,77,109,0.3);
  border-radius:50%;
  top:72px;
  animation: blushPulse 2s infinite;
}

.blush.left { left:15px; }
.blush.right { right:15px; }

@keyframes blushPulse {
  0%,100%{opacity:0.3;}
  50%{opacity:0.7;}
}

/* FLOATING HEARTS */
.heart {
  position:absolute;
  font-size:16px;
  color:red;
  animation: floatHeart 4s linear forwards;
}

@keyframes floatHeart {
  from {
    transform:translateY(0) scale(0.5);
    opacity:1;
  }
  to {
    transform:translateY(-120px) scale(1.3);
    opacity:0;
  }
}

/* TITLE */
h1 {
  font-family:'Dancing Script',cursive;
  color:white;
  font-size:3.2rem;
  margin-bottom:2rem;
}

/* BUTTONS */
.controls {
  position:relative;
  height:80px;
}

button {
  padding:16px 50px;
  border-radius:20px;
  border:none;
  font-size:1.2rem;
  font-weight:700;
  cursor:pointer;
  transition:0.4s cubic-bezier(0.34,1.56,0.64,1);
}

#yesBtn {
  background:white;
  color:var(--accent);
  box-shadow:0 10px 20px rgba(0,0,0,0.1);
}

#yesBtn:hover {
  transform:scale(1.25) rotate(3deg);
}

#noBtn {
  background:rgba(255,255,255,0.2);
  color:white;
  border:1px solid rgba(255,255,255,0.4);
  position:absolute;
  left:60%;
}

/* SUCCESS SCREEN */
#success-layer {
  position:fixed;
  inset:0;
  display:none;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  z-index:50;
  text-align:center;
}

.panda {
  font-size:100px;
  animation: jump 0.6s infinite alternate;
}

@keyframes jump {
  from { transform:translateY(0); }
  to { transform:translateY(-30px); }
}

/* RESPONSIVE */
@media(max-width:600px){
  .glass-surface { width:90%; padding:2.5rem; }
  h1 { font-size:2.5rem; }
}
</style>
</head>

<body>

<canvas id="fluid-canvas"></canvas>
<div id="bg-shader"></div>

<div class="glass-surface" id="main-card">

  <div class="face-box" id="face">
    <div class="blush left"></div>
    <div class="blush right"></div>

    <div class="eyes">
      <div class="eye"><div class="pupil"></div></div>
      <div class="eye"><div class="pupil"></div></div>
    </div>

    <div class="mouth" id="mouth"></div>
  </div>

  <h1>Be my Valentine?</h1>

  <div class="controls">
    <button id="yesBtn">Yes</button>
    <button id="noBtn">No</button>
  </div>

</div>

<div id="success-layer">
  <div style="display:flex;gap:20px;">
    <div class="panda">üêº</div>
    <div class="panda">üêº</div>
  </div>
  <h1>I knew you'd say yes! ‚ù§Ô∏è</h1>
</div>

<script>
/* =========================
   FACE INTERACTION LOGIC
========================= */

document.addEventListener("mousemove", e=>{
  document.documentElement.style.setProperty("--cursor-x", e.clientX+"px");
  document.documentElement.style.setProperty("--cursor-y", e.clientY+"px");

  const face=document.getElementById("face");
  const rect=face.getBoundingClientRect();
  const cx=rect.left+rect.width/2;
  const cy=rect.top+rect.height/2;

  document.querySelectorAll(".pupil").forEach(p=>{
    const angle=Math.atan2(e.clientY-cy,e.clientX-cx);
    p.style.transform=`translate(${Math.cos(angle)*6}px,${Math.sin(angle)*6}px)`;
  });
});

/* FLOATING HEARTS SPAWNER */
setInterval(()=>{
  const heart=document.createElement("div");
  heart.className="heart";
  heart.innerText="‚ù§Ô∏è";
  heart.style.left=(Math.random()*100)+"%";
  heart.style.top="75%";
  document.body.appendChild(heart);
  setTimeout(()=>heart.remove(),4000);
},900);

/* NO BUTTON FLEE */
const noBtn=document.getElementById("noBtn");
noBtn.addEventListener("mouseover",()=>{
  noBtn.style.left=Math.random()*300+"px";
  noBtn.style.top=Math.random()*120+"px";
});

/* SUCCESS */
document.getElementById("yesBtn").onclick=()=>{
  document.getElementById("main-card").style.display="none";
  document.getElementById("success-layer").style.display="flex";
};

/* =========================
   FLUID SPLASH CURSOR CORE
========================= */

const canvas = document.getElementById("fluid-canvas");
const gl = canvas.getContext("webgl2", { alpha: true });

if (!gl) {
  alert("WebGL2 not supported");
}

let pointers = [];
let lastTime = Date.now();

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

window.addEventListener("resize", () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});

/* =========================
   POINTER CLASS
========================= */
class Pointer {
  constructor() {
    this.id = -1;
    this.x = 0;
    this.y = 0;
    this.dx = 0;
    this.dy = 0;
    this.down = false;
    this.moved = false;
    this.color = { r: 1, g: 0.3, b: 0.5 };
  }
}

pointers.push(new Pointer());

/* =========================
   CONFIG
========================= */
const config = {
  SIM_RESOLUTION: 128,
  DYE_RESOLUTION: 1024,
  DENSITY_DISSIPATION: 3.5,
  VELOCITY_DISSIPATION: 2.0,
  PRESSURE: 0.1,
  PRESSURE_ITERATIONS: 20,
  CURL: 3,
  SPLAT_RADIUS: 0.2,
  SPLAT_FORCE: 6000,
};

/* =========================
   SHADER UTILS
========================= */
function compileShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(shader));
  }
  return shader;
}

function createProgram(vertex, fragment) {
  const program = gl.createProgram();
  gl.attachShader(program, vertex);
  gl.attachShader(program, fragment);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
  }
  return program;
}

/* =========================
   BASE SHADERS
========================= */
const baseVertexShader = compileShader(gl.VERTEX_SHADER, `
precision highp float;
attribute vec2 aPosition;
varying vec2 vUv;
varying vec2 vL;
varying vec2 vR;
varying vec2 vT;
varying vec2 vB;
uniform vec2 texelSize;

void main(){
  vUv = aPosition * 0.5 + 0.5;
  vL = vUv - vec2(texelSize.x, 0.0);
  vR = vUv + vec2(texelSize.x, 0.0);
  vT = vUv + vec2(0.0, texelSize.y);
  vB = vUv - vec2(0.0, texelSize.y);
  gl_Position = vec4(aPosition,0.0,1.0);
}
`);

const copyShader = compileShader(gl.FRAGMENT_SHADER, `
precision mediump float;
varying vec2 vUv;
uniform sampler2D uTexture;
void main(){
  gl_FragColor = texture2D(uTexture, vUv);
}
`);

const clearShader = compileShader(gl.FRAGMENT_SHADER, `
precision mediump float;
varying vec2 vUv;
uniform sampler2D uTexture;
uniform float value;
void main(){
  gl_FragColor = value * texture2D(uTexture, vUv);
}
`);

const splatShader = compileShader(gl.FRAGMENT_SHADER, `
precision highp float;
varying vec2 vUv;
uniform sampler2D uTarget;
uniform vec2 point;
uniform float aspectRatio;
uniform vec3 color;
uniform float radius;

void main(){
  vec2 p = vUv - point;
  p.x *= aspectRatio;
  vec3 splat = exp(-dot(p,p) / radius) * color;
  vec3 base = texture2D(uTarget, vUv).xyz;
  gl_FragColor = vec4(base + splat,1.0);
}
`);

const advectionShader = compileShader(gl.FRAGMENT_SHADER, `
precision highp float;
varying vec2 vUv;
uniform sampler2D uVelocity;
uniform sampler2D uSource;
uniform vec2 texelSize;
uniform float dt;
uniform float dissipation;

void main(){
  vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;
  vec4 result = texture2D(uSource, coord);
  float decay = 1.0 + dissipation * dt;
  gl_FragColor = result / decay;
}
`);

const divergenceShader = compileShader(gl.FRAGMENT_SHADER, `
precision mediump float;
varying vec2 vUv;
varying vec2 vL;
varying vec2 vR;
varying vec2 vT;
varying vec2 vB;
uniform sampler2D uVelocity;

void main(){
  float L = texture2D(uVelocity, vL).x;
  float R = texture2D(uVelocity, vR).x;
  float T = texture2D(uVelocity, vT).y;
  float B = texture2D(uVelocity, vB).y;
  float div = 0.5 * (R - L + T - B);
  gl_FragColor = vec4(div,0.0,0.0,1.0);
}
`);

const curlShader = compileShader(gl.FRAGMENT_SHADER, `
precision mediump float;
varying vec2 vUv;
varying vec2 vL;
varying vec2 vR;
varying vec2 vT;
varying vec2 vB;
uniform sampler2D uVelocity;

void main(){
  float L = texture2D(uVelocity, vL).y;
  float R = texture2D(uVelocity, vR).y;
  float T = texture2D(uVelocity, vT).x;
  float B = texture2D(uVelocity, vB).x;
  float vorticity = R - L - T + B;
  gl_FragColor = vec4(vorticity,0.0,0.0,1.0);
}
`);

const pressureShader = compileShader(gl.FRAGMENT_SHADER, `
precision mediump float;
varying vec2 vUv;
varying vec2 vL;
varying vec2 vR;
varying vec2 vT;
varying vec2 vB;
uniform sampler2D uPressure;
uniform sampler2D uDivergence;

void main(){
  float L = texture2D(uPressure, vL).x;
  float R = texture2D(uPressure, vR).x;
  float T = texture2D(uPressure, vT).x;
  float B = texture2D(uPressure, vB).x;
  float div = texture2D(uDivergence, vUv).x;
  float pressure = (L + R + T + B - div) * 0.25;
  gl_FragColor = vec4(pressure,0.0,0.0,1.0);
}
`);

const gradientSubtractShader = compileShader(gl.FRAGMENT_SHADER, `
precision mediump float;
varying vec2 vUv;
varying vec2 vL;
varying vec2 vR;
varying vec2 vT;
varying vec2 vB;
uniform sampler2D uPressure;
uniform sampler2D uVelocity;

void main(){
  float L = texture2D(uPressure, vL).x;
  float R = texture2D(uPressure, vR).x;
  float T = texture2D(uPressure, vT).x;
  float B = texture2D(uPressure, vB).x;
  vec2 velocity = texture2D(uVelocity, vUv).xy;
  velocity -= vec2(R-L, T-B);
  gl_FragColor = vec4(velocity,0.0,1.0);
}
`);

/* =========================
   PROGRAMS
========================= */
const programs = {
  copy: createProgram(baseVertexShader, copyShader),
  clear: createProgram(baseVertexShader, clearShader),
  splat: createProgram(baseVertexShader, splatShader),
  advection: createProgram(baseVertexShader, advectionShader),
  divergence: createProgram(baseVertexShader, divergenceShader),
  curl: createProgram(baseVertexShader, curlShader),
  pressure: createProgram(baseVertexShader, pressureShader),
  gradientSubtract: createProgram(baseVertexShader, gradientSubtractShader),
};

/* =========================
   BUFFERS
========================= */
const quadBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1,-1,
  -1, 1,
   1, 1,
   1,-1
]), gl.STATIC_DRAW);

const indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0,1,2,0,2,3]), gl.STATIC_DRAW);

/* =========================
   FRAMEBUFFERS
========================= */
function createFBO(w,h){
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,w,h,0,gl.RGBA,gl.FLOAT,null);

  const fbo = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER,fbo);
  gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,tex,0);

  return {texture:tex,fbo:fbo,width:w,height:h};
}

let velocity = createFBO(128,128);
let dye = createFBO(1024,1024);
let pressure = createFBO(128,128);
let divergence = createFBO(128,128);
let curl = createFBO(128,128);

/* =========================
   DRAW QUAD
========================= */
function drawQuad(program){
  gl.useProgram(program);
  const posLoc = gl.getAttribLocation(program,"aPosition");
  gl.enableVertexAttribArray(posLoc);
  gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
  gl.vertexAttribPointer(posLoc,2,gl.FLOAT,false,0,0);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuffer);
  gl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0);
}

/* =========================
   SPLAT FUNCTION
========================= */
function splat(x,y,dx,dy,color){
  gl.viewport(0,0,velocity.width,velocity.height);
  gl.bindFramebuffer(gl.FRAMEBUFFER, velocity.fbo);
  gl.useProgram(programs.splat);
  gl.uniform2f(gl.getUniformLocation(programs.splat,"point"), x,y);
  gl.uniform1f(gl.getUniformLocation(programs.splat,"aspectRatio"), canvas.width/canvas.height);
  gl.uniform3f(gl.getUniformLocation(programs.splat,"color"), dx,dy,0.0);
  gl.uniform1f(gl.getUniformLocation(programs.splat,"radius"), config.SPLAT_RADIUS);
  drawQuad(programs.splat);

  gl.viewport(0,0,dye.width,dye.height);
  gl.bindFramebuffer(gl.FRAMEBUFFER, dye.fbo);
  gl.uniform3f(gl.getUniformLocation(programs.splat,"color"), color.r,color.g,color.b);
  drawQuad(programs.splat);
}

/* =========================
   POINTER EVENTS
========================= */

const pointer = pointers[0];

function updatePointerDown(e) {
  pointer.down = true;
  pointer.moved = false;
  pointer.x = e.clientX / canvas.width;
  pointer.y = 1 - e.clientY / canvas.height;
  pointer.dx = 0;
  pointer.dy = 0;
  pointer.color = randomColor();
}

function updatePointerMove(e) {
  const x = e.clientX / canvas.width;
  const y = 1 - e.clientY / canvas.height;
  pointer.dx = x - pointer.x;
  pointer.dy = y - pointer.y;
  pointer.x = x;
  pointer.y = y;
  pointer.moved = true;
}

function updatePointerUp() {
  pointer.down = false;
}

window.addEventListener("mousedown", updatePointerDown);
window.addEventListener("mousemove", updatePointerMove);
window.addEventListener("mouseup", updatePointerUp);

/* TOUCH */
window.addEventListener("touchstart", e => {
  const t = e.touches[0];
  updatePointerDown(t);
});
window.addEventListener("touchmove", e => {
  const t = e.touches[0];
  updatePointerMove(t);
});
window.addEventListener("touchend", updatePointerUp);

/* =========================
   COLOR UTILS
========================= */
function randomColor() {
  const h = Math.random();
  return HSVtoRGB(h, 1.0, 1.0);
}

function HSVtoRGB(h, s, v) {
  let r, g, b;
  let i = Math.floor(h * 6);
  let f = h * 6 - i;
  let p = v * (1 - s);
  let q = v * (1 - f * s);
  let t = v * (1 - (1 - f) * s);
  switch (i % 6) {
    case 0: r = v; g = t; b = p; break;
    case 1: r = q; g = v; b = p; break;
    case 2: r = p; g = v; b = t; break;
    case 3: r = p; g = q; b = v; break;
    case 4: r = t; g = p; b = v; break;
    case 5: r = v; g = p; b = q; break;
  }
  return { r, g, b };
}

/* =========================
   TIME STEP
========================= */
function calcDeltaTime() {
  const now = Date.now();
  let dt = (now - lastTime) / 1000;
  dt = Math.min(dt, 0.016);
  lastTime = now;
  return dt;
}

/* =========================
   FLUID SIM STEP
========================= */
function step(dt) {

  // Curl
  gl.viewport(0,0,curl.width,curl.height);
  gl.bindFramebuffer(gl.FRAMEBUFFER, curl.fbo);
  gl.useProgram(programs.curl);
  drawQuad(programs.curl);

  // Divergence
  gl.viewport(0,0,divergence.width,divergence.height);
  gl.bindFramebuffer(gl.FRAMEBUFFER, divergence.fbo);
  gl.useProgram(programs.divergence);
  drawQuad(programs.divergence);

  // Pressure solve
  for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {
    gl.viewport(0,0,pressure.width,pressure.height);
    gl.bindFramebuffer(gl.FRAMEBUFFER, pressure.fbo);
    gl.useProgram(programs.pressure);
    drawQuad(programs.pressure);
  }

  // Gradient subtract
  gl.viewport(0,0,velocity.width,velocity.height);
  gl.bindFramebuffer(gl.FRAMEBUFFER, velocity.fbo);
  gl.useProgram(programs.gradientSubtract);
  drawQuad(programs.gradientSubtract);

  // Advection velocity
  gl.viewport(0,0,velocity.width,velocity.height);
  gl.bindFramebuffer(gl.FRAMEBUFFER, velocity.fbo);
  gl.useProgram(programs.advection);
  gl.uniform1f(gl.getUniformLocation(programs.advection,"dt"), dt);
  gl.uniform1f(gl.getUniformLocation(programs.advection,"dissipation"), config.VELOCITY_DISSIPATION);
  drawQuad(programs.advection);

  // Advection dye
  gl.viewport(0,0,dye.width,dye.height);
  gl.bindFramebuffer(gl.FRAMEBUFFER, dye.fbo);
  gl.useProgram(programs.advection);
  gl.uniform1f(gl.getUniformLocation(programs.advection,"dt"), dt);
  gl.uniform1f(gl.getUniformLocation(programs.advection,"dissipation"), config.DENSITY_DISSIPATION);
  drawQuad(programs.advection);
}

/* =========================
   RENDER
========================= */
function render() {
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.useProgram(programs.copy);
  gl.bindTexture(gl.TEXTURE_2D, dye.texture);
  drawQuad(programs.copy);
}

/* =========================
   APPLY INPUT
========================= */
function applyInputs() {
  if (pointer.moved && pointer.down) {
    splat(pointer.x, pointer.y,
      pointer.dx * config.SPLAT_FORCE,
      pointer.dy * config.SPLAT_FORCE,
      pointer.color
    );
    pointer.moved = false;
  }
}

/* =========================
   MAIN LOOP
========================= */
function update() {
  const dt = calcDeltaTime();
  applyInputs();
  step(dt);
  render();
  requestAnimationFrame(update);
}

update();

/* =========================
   CLEANUP SAFETY
========================= */
window.addEventListener("beforeunload",()=>{
  gl.getExtension("WEBGL_lose_context")?.loseContext();
});

</script>
</body>
</html>